(* https://github.com/fsprojects/FSharp.Compatibility/blob/master/FSharp.Compatibility.OCaml.LexYacc/Parsing.fs *)
(*

Copyright 2005-2009 Microsoft Corporation
Copyright 2012 Jack Pappas

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*)

/// The run-time library for parsers generated by fsyacc.
[<CompilerMessage(
    "This module is for ML compatibility. \
    This message can be disabled using '--nowarn:62' or '#nowarn \"62\"'.",
    62, IsHidden = true)>]
[<CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]
module FSharp.Compatibility.OCaml.Parsing

open FSharp.Text.Lexing
open FSharp.Text.Parsing


//
exception Parse_error = RecoverableParseError

//
let private dummyProvider =
    let err _  = failwith "You must generate your parser using the '--ml-compatibility' option or call 'Parsing.set_parse_state parseState' \
                            in each action before using functions from the Parsing module.  This is because the module uses global state which \
                            must be set up for use in each parsing action. Review the notes in the 'Microsoft.FSharp.Compatibility.OCaml.Parsing' \
                            module if you are using parsers on multiple threads."
    { new IParseState with 
        member x.InputRange(i) = err();
        member p.InputStartPosition(n) = err();
        member p.InputEndPosition(n) = err();
        member x.ResultRange = err();
        member x.GetInput(i) = err();
        member x.ParserLocalStore = err();
        member x.RaiseError() = err()  
      }

//
let mutable private parse_information = dummyProvider

//
let private parse_error s =
    parse_information.RaiseError () (failwith s : unit)

//
let private set_parse_state (x : IParseState) =
    parse_information <- x

//
let private enforce_nonnull_pos p : Lexing.position =
    match box p with
    | null -> Position.Empty
    | _ -> p

//
let symbol_start_pos () =
    parse_information.ResultRange
    |> fst
    |> enforce_nonnull_pos

//
let symbol_end_pos () =
    parse_information.ResultRange
    |> snd
    |> enforce_nonnull_pos

//
let rhs_start_pos (n : int) =
    parse_information.InputRange n
    |> fst
    |> enforce_nonnull_pos

//
let rhs_end_pos (n : int) =
    parse_information.InputRange n
    |> snd
    |> enforce_nonnull_pos

//
let symbol_start () =
    (symbol_start_pos()).pos_cnum
//
let symbol_end () =
    (symbol_end_pos()).pos_cnum
//
let rhs_start n =
    (rhs_start_pos n).pos_cnum
//
let rhs_end n =
    (rhs_end_pos n).pos_cnum

/// Empty the parser stack. Call it just after a parsing function has returned to remove
/// all pointers from the parser stack to structures that were built by semantic actions
/// during parsing. This is optional, but lowers the memory requirements of the programs.
let clear_parser () =
    // TEMP : Don't do anything for now -- programs should work as-is, though they won't
    // benefit from freeing the parser structures. This won't matter anyway, once fsyacc
    // modifications are released.
    ()

////
//let set_trace (flag : bool) : bool =
//    raise <| System.NotImplementedException "Parsing.set_trace"